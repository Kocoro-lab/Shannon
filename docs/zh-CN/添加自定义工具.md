# 向 Shannon 添加自定义工具

**开源采用者扩展 Shannon 自定义工具的完整指南**

---

## 目录

1. [概述](#概述)
2. [快速开始：添加 MCP 工具](#快速开始添加-mcp-工具)
3. [添加 OpenAPI 工具](#添加-openapi-工具)
4. [添加内置 Python 工具](#添加内置-python-工具)
5. [配置参考](#配置参考)
6. [测试与验证](#测试与验证)
7. [故障排除](#故障排除)
8. [安全最佳实践](#安全最佳实践)

---

## 概述

Shannon 支持三种添加自定义工具的方式：

| 方法 | 最适用于 | 代码修改 | 需要重启 |
|------|---------|----------|---------|
| **MCP 工具** | 外部 HTTP API，快速原型开发 | 无 | ✅ 仅服务 |
| **OpenAPI 工具** | 具有 OpenAPI 规范的 REST API | 无 | ✅ 仅服务 |
| **内置工具** | 复杂逻辑，数据库访问，性能要求高 | Python 代码 | ✅ 仅服务 |

**主要特性：**
- ✅ 无需修改 Proto/Rust/Go（所有工具使用通用容器）
- ✅ 通过 API 或 YAML 配置动态注册
- ✅ 内置速率限制和熔断器
- ✅ 域名白名单安全控制
- ✅ 成本跟踪和预算控制

---

## 快速开始：添加 MCP 工具

MCP（Model Context Protocol）工具让你无需修改代码即可将任何 HTTP 端点集成为 Shannon 工具。

### 步骤 1: 添加工具定义

编辑 `config/shannon.yaml` 中的 `mcp_tools` 部分：

```yaml
mcp_tools:
  weather_forecast:
    enabled: true
    url: "https://api.weather.com/v1/forecast"
    func_name: "get_weather"
    description: "获取指定位置的天气预报"
    category: "data"
    cost_per_use: 0.001
    parameters:
      - name: "location"
        type: "string"
        required: true
        description: "城市名称或坐标"
      - name: "units"
        type: "string"
        required: false
        description: "温度单位 (celsius/fahrenheit)"
        enum: ["celsius", "fahrenheit"]
    headers:
      X-API-Key: "${WEATHER_API_KEY}"  # 从 .env 解析
```

**必填字段：**
- `enabled`: 设置为 `true` 以激活
- `url`: HTTP 端点（必须是 POST，接受 JSON）
- `func_name`: 内部函数名称
- `description`: 向 LLM 展示的清晰描述
- `category`: 工具类别（如 `search`、`data`、`analytics`、`code`）
- `cost_per_use`: 预估成本（美元）
- `parameters`: 参数定义数组

**可选字段：**
- `headers`: 用于身份验证的 HTTP 头（使用 `${ENV_VAR}` 引用环境变量）

### 步骤 2: 配置域名访问

**开发环境（宽松）：**

添加到 `.env`：
```bash
MCP_ALLOWED_DOMAINS=*  # 通配符 - 允许所有域名
```

**生产环境（推荐）：**

```bash
MCP_ALLOWED_DOMAINS=localhost,127.0.0.1,api.weather.com,api.example.com
```

或在 `deploy/compose/docker-compose.yml` 中设置：
```yaml
services:
  llm-service:
    environment:
      - MCP_ALLOWED_DOMAINS=api.weather.com,api.stocks.com
```

### 步骤 3: 添加 API 密钥

将 API 密钥添加到 `.env`：

```bash
# MCP 工具 API 密钥
WEATHER_API_KEY=your_api_key_here
STOCK_API_KEY=your_stock_key_here
```

### 步骤 4: 重启服务

**重要：** 必须**重新创建**服务（而不只是重启）：

```bash
docker compose -f deploy/compose/docker-compose.yml up -d --force-recreate llm-service
```

等待健康检查：
```bash
docker inspect shannon-llm-service-1 --format='{{.State.Health.Status}}'
```

### 步骤 5: 验证注册

检查日志：
```bash
docker compose logs llm-service | grep "Loaded MCP tool"
```

通过 API 列出工具：
```bash
curl http://localhost:8000/tools/list | jq .
```

获取工具模式：
```bash
curl http://localhost:8000/tools/weather_forecast/schema | jq .
```

### 步骤 6: 测试工具

**直接执行：**
```bash
curl -X POST http://localhost:8000/tools/execute \
  -H "Content-Type: application/json" \
  -d '{
    "tool_name": "weather_forecast",
    "parameters": {"location": "Tokyo", "units": "celsius"}
  }'
```

**通过工作流：**
```bash
SESSION_ID="test-$(date +%s)" ./scripts/submit_task.sh "东京的天气预报是什么？"
```

### 备选方案：运行时 API 注册

仅用于开发/测试（重启后工具会丢失）：

```bash
# 在 .env 中设置管理员令牌
MCP_REGISTER_TOKEN=your_secret_token

# 注册工具
curl -X POST http://localhost:8000/tools/mcp/register \
  -H "Authorization: Bearer your_secret_token" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "weather_forecast",
    "url": "https://api.weather.com/v1/forecast",
    "func_name": "get_weather",
    "description": "获取天气预报",
    "category": "data",
    "parameters": [
      {"name": "location", "type": "string", "required": true},
      {"name": "units", "type": "string", "enum": ["celsius", "fahrenheit"]}
    ]
  }'
```

### MCP 请求约定

Shannon 以此格式发送 POST 请求：

```json
{
  "function": "get_weather",
  "args": {
    "location": "Tokyo",
    "units": "celsius"
  }
}
```

你的端点应返回 JSON：
```json
{
  "temperature": 18,
  "condition": "Cloudy",
  "humidity": 65
}
```

---

## 添加 OpenAPI 工具

对于具有 OpenAPI 3.x 规范的 REST API，Shannon 可以自动生成工具。

### 功能特性

**支持的功能：**
- ✅ OpenAPI 3.0 和 3.1 规范
- ✅ 基于 URL 或内联规范加载
- ✅ JSON 请求/响应体
- ✅ 路径和查询参数
- ✅ Bearer、API Key（header/query）、Basic 认证
- ✅ 通过 operationId 或 tags 过滤操作
- ✅ 熔断器（5 次失败 → 60 秒冷却）
- ✅ 指数退避重试逻辑（3 次重试，可通过 `OPENAPI_RETRIES` 配置）
- ✅ 可配置的速率限制和超时
- ✅ 相对服务器 URL（根据规范 URL 解析）
- ✅ 基本 `$ref` 解析（本地引用 `#/components/schemas/*`）

**限制（MVP）：**

Shannon OpenAPI 集成对约 70% 的 REST API（基于 JSON 和简单认证）已达到生产就绪。以下功能**尚未支持：**

1. **❌ 文件上传 API (multipart/form-data)**
   - 无法上传文件或二进制数据
   - 解决方案：在 JSON 体中使用 base64 编码文件
   - 受影响的 API：图像生成、文件处理、文档上传 API

2. **❌ OAuth 保护的 API**
   - 不支持 OAuth 2.0 流程（授权码、客户端凭证）
   - 只能使用 Bearer 令牌（手动获取）
   - 受影响的 API：Google APIs、GitHub、Slack、Twitter 等
   - 解决方案：手动获取 OAuth 令牌并使用 `bearer` auth_type

3. **❌ 复杂参数编码**
   - 不支持 `style`、`explode` 或 `deepObject` 序列化
   - 仅基本路径/查询参数替换
   - 受影响的 API：具有复杂数组/对象查询参数的 API

4. **❌ 多文件 OpenAPI 规范**
   - 不支持远程 `$ref` 解析（如 `https://example.com/schemas/Pet.json`）
   - 仅支持本地引用（`#/components/...`）
   - 解决方案：将外部模式合并到单个规范文件

5. **❌ 高级模式组合器**
   - 不支持 `allOf`、`oneOf`、`anyOf`
   - 仅基本类型映射
   - 受影响的 API：具有多态类型或复杂验证的 API

6. **❌ 表单编码请求**
   - 不支持 `application/x-www-form-urlencoded` 内容类型
   - 仅支持 JSON 请求体

**运行良好的场景：**
- ✅ 具有 JSON 请求/响应的简单 REST API
- ✅ 使用 Bearer/API Key/Basic 认证的 API
- ✅ 读取密集型操作（GET 请求）
- ✅ 具有本地 `$ref` 引用的良好结构规范
- ✅ 路径和查询参数（基本类型）

**重要提示：** 对于具有相对服务器 URL（如 `/api/v3`）的规范，必须通过 `spec_url`（而非 `spec_inline`）提供规范，以便 Shannon 可以解析完整的基础 URL。示例：PetStore 规范具有 `servers: [{url: "/api/v3"}]`，当从 `https://petstore3.swagger.io/api/v3/openapi.json` 加载时解析为 `https://petstore3.swagger.io/api/v3`。

### 步骤 1: 添加工具定义

编辑 `config/shannon.yaml` 中的 `openapi_tools`：

```yaml
openapi_tools:
  petstore:
    enabled: true
    spec_url: "https://petstore3.swagger.io/api/v3/openapi.json"
    # 或使用内联规范：
    # spec_inline: |
    #   <粘贴 OpenAPI JSON/YAML 在这里>

    auth_type: "api_key"  # none|api_key|bearer|basic
    auth_config:
      api_key_name: "X-API-Key"           # Header 名称或查询参数名称
      api_key_location: "header"          # header|query
      api_key_value: "$PETSTORE_API_KEY"  # 使用 $ 前缀引用环境变量

    category: "data"
    base_cost_per_use: 0.001
    rate_limit: 30                        # 每分钟请求数
    timeout_seconds: 30                   # 请求超时
    max_response_bytes: 10485760          # 最大响应大小（10MB）

    # 可选：过滤特定操作
    operations:
      - "getPetById"
      - "findPetsByStatus"

    # 可选：按标签过滤
    # tags:
    #   - "pet"

    # 可选：覆盖规范中的基础 URL
    # base_url: "https://custom-petstore.example.com"
```

### 认证示例

**Bearer 令牌（GitHub API）：**
```yaml
github:
  enabled: true
  spec_url: "https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json"
  auth_type: "bearer"
  auth_config:
    token: "$GITHUB_TOKEN"
  operations:
    - "repos/get"
    - "repos/list-for-user"
```

**查询中的 API Key（OpenWeather）：**
```yaml
weather:
  enabled: true
  spec_url: "https://api.openweathermap.org/data/3.0/openapi.json"
  auth_type: "api_key"
  auth_config:
    api_key_name: "appid"
    api_key_location: "query"
    api_key_value: "$OPENWEATHER_API_KEY"
```

**Basic 认证：**
```yaml
custom_api:
  enabled: true
  spec_url: "https://api.example.com/openapi.json"
  auth_type: "basic"
  auth_config:
    username: "$API_USERNAME"
    password: "$API_PASSWORD"
```

### 步骤 2: 配置环境

添加到 `.env`：

```bash
# OpenAPI 安全
OPENAPI_ALLOWED_DOMAINS=*                # 开发用 *，生产用具体域名
OPENAPI_MAX_SPEC_SIZE=5242880            # 默认 5MB
OPENAPI_FETCH_TIMEOUT=30                 # 秒

# API 密钥
PETSTORE_API_KEY=your_key_here
GITHUB_TOKEN=ghp_xxxxxxxxxxxxx
OPENWEATHER_API_KEY=your_key
API_USERNAME=username
API_PASSWORD=password

# 与 MCP 相同的注册令牌
MCP_REGISTER_TOKEN=your_admin_token
```

### 步骤 3: 重启服务

```bash
docker compose -f deploy/compose/docker-compose.yml up -d --force-recreate llm-service
```

### 步骤 4: 验证和测试

**首先验证规范：**
```bash
curl -X POST http://localhost:8000/tools/openapi/validate \
  -H "Content-Type: application/json" \
  -d '{"spec_url": "https://petstore3.swagger.io/api/v3/openapi.json"}' | jq .
```

**响应：**
```json
{
  "valid": true,
  "operations_count": 19,
  "operations": [
    {"operation_id": "getPetById", "method": "GET", "path": "/pet/{petId}"},
    {"operation_id": "addPet", "method": "POST", "path": "/pet"}
  ],
  "base_url": "https://petstore3.swagger.io/api/v3"
}
```

**列出已注册工具：**
```bash
curl http://localhost:8000/tools/list | grep Pet
```

**执行工具：**
```bash
curl -X POST http://localhost:8000/tools/execute \
  -H "Content-Type: application/json" \
  -d '{
    "tool_name": "getPetById",
    "parameters": {"petId": 1}
  }' | jq .
```

### 备选方案：运行时注册

```bash
curl -X POST http://localhost:8000/tools/openapi/register \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_admin_token" \
  -d '{
    "name": "petstore",
    "spec_url": "https://petstore3.swagger.io/api/v3/openapi.json",
    "auth_type": "none",
    "category": "data",
    "operations": ["getPetById", "findPetsByStatus"],
    "rate_limit": 15,
    "timeout_seconds": 10
  }' | jq .
```

**响应包含验证：**
```json
{
  "success": true,
  "collection_name": "petstore",
  "operations_registered": ["getPetById", "findPetsByStatus"],
  "rate_limit": 15,
  "timeout_seconds": 10,
  "max_response_bytes": 10485760
}
```

---

## 添加内置 Python 工具

用于复杂逻辑、数据库访问或性能关键操作。

### 何时使用内置工具

**使用内置工具的场景：**
- 需要直接数据库/Redis 访问
- 需要复杂的 Python 库（pandas、numpy）
- 性能关键（避免 HTTP 往返）
- 需要会话状态管理
- 实现安全敏感操作

**改用 MCP/OpenAPI 的场景：**
- 集成外部 API
- 无代码部署
- 快速原型开发
- 第三方服务集成

### 步骤 1: 创建工具类

在 `python/llm-service/llm_service/tools/builtin/my_custom_tool.py` 创建文件：

```python
from typing import Any, Dict, List, Optional
from ..base import Tool, ToolMetadata, ToolParameter, ToolParameterType, ToolResult

class MyCustomTool(Tool):
    """
    工具功能简要描述。
    """

    def _get_metadata(self) -> ToolMetadata:
        """定义工具元数据。"""
        return ToolMetadata(
            name="my_custom_tool",
            version="1.0.0",
            description="清晰描述以便 LLM 理解何时/如何使用此工具",
            category="custom",  # search, data, analytics, code, file, custom
            author="你的名字",
            requires_auth=False,
            timeout_seconds=30,
            memory_limit_mb=128,
            sandboxed=False,
            session_aware=False,  # 如果工具需要会话状态则设为 True
            dangerous=False,      # 文件写入、代码执行设为 True
            cost_per_use=0.001,   # 每次调用的美元成本
            rate_limit=60,        # 每分钟请求数（由基类强制执行）
        )

    def _get_parameters(self) -> List[ToolParameter]:
        """定义带验证的工具参数。"""
        return [
            ToolParameter(
                name="required_param",
                type=ToolParameterType.STRING,
                description="向 LLM 展示的描述",
                required=True,
            ),
            ToolParameter(
                name="optional_number",
                type=ToolParameterType.INTEGER,
                description="可选的数字参数",
                required=False,
                default=10,
                min_value=1,
                max_value=100,
            ),
            ToolParameter(
                name="choice_param",
                type=ToolParameterType.STRING,
                description="具有预定义选项的参数",
                required=False,
                enum=["option1", "option2", "option3"],
            ),
        ]

    async def _execute_impl(
        self,
        session_context: Optional[Dict] = None,
        **kwargs
    ) -> ToolResult:
        """
        执行工具逻辑。

        参数:
            session_context: 如果 session_aware=True 则为会话数据
            **kwargs: 工具参数（自动验证）

        返回:
            带成功/错误状态的 ToolResult
        """
        try:
            # 提取参数（已由基类验证）
            required_param = kwargs.get("required_param")
            optional_number = kwargs.get("optional_number", 10)
            choice_param = kwargs.get("choice_param")

            # 你的工具逻辑在这里
            result = self._do_work(required_param, optional_number, choice_param)

            return ToolResult(
                success=True,
                output=result,
                metadata={"processed": True},
                execution_time_ms=50,
            )

        except Exception as e:
            return ToolResult(
                success=False,
                output=None,
                error=f"工具执行失败: {str(e)}"
            )

    def _do_work(self, param1, param2, param3):
        """你的实际实现。"""
        # 示例：数据库查询、API 调用、计算
        return {"result": "success", "data": [1, 2, 3]}
```

### 步骤 2: 注册工具

编辑 `python/llm-service/llm_service/api/tools.py` 第 228 行附近：

```python
# 在顶部添加导入
from ..tools.builtin.my_custom_tool import MyCustomTool

# 在 startup_event() 中添加到注册列表
@router.on_event("startup")
async def startup_event():
    registry = get_registry()

    tools_to_register = [
        WebSearchTool,
        CalculatorTool,
        FileReadTool,
        FileWriteTool,
        PythonWasiExecutorTool,
        MyCustomTool,  # 在这里添加你的工具
    ]

    for tool_class in tools_to_register:
        try:
            registry.register(tool_class)
            logger.info(f"Registered tool: {tool_class.__name__}")
        except Exception as e:
            logger.error(f"Failed to register {tool_class.__name__}: {e}")
```

### 步骤 3: 重启服务

```bash
docker compose -f deploy/compose/docker-compose.yml up -d --force-recreate llm-service
```

### 步骤 4: 测试工具

```bash
# 验证注册
curl http://localhost:8000/tools/list | grep my_custom_tool

# 获取模式
curl http://localhost:8000/tools/my_custom_tool/schema | jq .

# 执行
curl -X POST http://localhost:8000/tools/execute \
  -H "Content-Type: application/json" \
  -d '{
    "tool_name": "my_custom_tool",
    "parameters": {
      "required_param": "test",
      "optional_number": 42,
      "choice_param": "option1"
    }
  }' | jq .
```

### 高级：会话感知工具

用于跨执行维护状态的工具：

```python
class SessionAwareTool(Tool):
    def _get_metadata(self) -> ToolMetadata:
        return ToolMetadata(
            name="session_tool",
            session_aware=True,  # 启用会话上下文
            ...
        )

    async def _execute_impl(
        self,
        session_context: Optional[Dict] = None,
        **kwargs
    ) -> ToolResult:
        # 访问会话数据
        session_id = session_context.get("session_id") if session_context else None
        user_id = session_context.get("user_id") if session_context else None

        # 存储/检索会话特定数据
        # 示例：Redis、数据库、内存缓存

        return ToolResult(success=True, output={"session": session_id})
```

---

## 配置参考

### MCP 工具配置

```yaml
mcp_tools:
  tool_name:
    enabled: true                    # 必填：启用/禁用工具
    url: "https://api.example.com"   # 必填：HTTP 端点
    func_name: "function_name"       # 必填：远程函数名
    description: "工具描述"          # 必填：LLM 可见描述
    category: "data"                 # 必填：工具类别
    cost_per_use: 0.001             # 必填：美元成本
    parameters:                      # 必填：参数定义
      - name: "param1"
        type: "string"               # string|integer|float|boolean|array|object
        required: true
        description: "参数描述"
        enum: ["val1", "val2"]       # 可选：允许的值
        default: "val1"              # 可选：默认值
    headers:                         # 可选：HTTP 头
      X-API-Key: "${API_KEY_VAR}"   # 使用 ${} 引用环境变量
```

### OpenAPI 工具配置

```yaml
openapi_tools:
  collection_name:
    enabled: true
    spec_url: "https://api.example.com/openapi.json"  # 或 spec_inline
    auth_type: "none"                # none|api_key|bearer|basic
    auth_config:                     # auth_type != "none" 时必填
      # 对于 api_key:
      api_key_name: "X-API-Key"
      api_key_location: "header"     # header|query
      api_key_value: "$API_KEY"
      # 对于 bearer:
      token: "$BEARER_TOKEN"
      # 对于 basic:
      username: "$USERNAME"
      password: "$PASSWORD"
    category: "api"
    base_cost_per_use: 0.001
    rate_limit: 30                   # 每分钟请求数
    timeout_seconds: 30              # 请求超时
    max_response_bytes: 10485760     # 最大响应大小（字节）
    operations:                      # 可选：过滤操作
      - "operationId1"
      - "operationId2"
    tags:                            # 可选：按标签过滤
      - "tag1"
    base_url: "https://override.com" # 可选：覆盖规范基础 URL
```

### 环境变量

**MCP 配置：**
```bash
# 域名安全
MCP_ALLOWED_DOMAINS=localhost,127.0.0.1,api.example.com  # 或开发用 *

# 熔断器
MCP_CB_FAILURES=5                    # 熔断前的失败次数
MCP_CB_RECOVERY_SECONDS=60           # 熔断开启持续时间

# 请求限制
MCP_MAX_RESPONSE_BYTES=10485760      # 默认 10MB
MCP_RETRIES=3                        # 重试次数
MCP_TIMEOUT_SECONDS=10               # 请求超时

# 注册安全
MCP_REGISTER_TOKEN=your_secret       # API 注册保护
```

**OpenAPI 配置：**
```bash
# 域名安全
OPENAPI_ALLOWED_DOMAINS=*            # 逗号分隔或开发用 *
OPENAPI_MAX_SPEC_SIZE=5242880        # 5MB 规范大小限制
OPENAPI_FETCH_TIMEOUT=30             # 规范获取超时

# 请求行为
OPENAPI_RETRIES=3                    # 重试次数（默认：3，匹配 MCP）
```

**工具特定 API 密钥：**
```bash
# 在这里添加你的工具 API 密钥
WEATHER_API_KEY=your_key
STOCK_API_KEY=your_key
GITHUB_TOKEN=ghp_xxxxx
PETSTORE_API_KEY=your_key
# ... 根据需要添加更多
```

---

## 测试与验证

### 健康检查

```bash
# 检查服务健康
curl http://localhost:8081/health | jq .

# 检查 LLM 服务状态
docker inspect shannon-llm-service-1 --format='{{.State.Health.Status}}'
```

### 列出工具

```bash
# 所有工具
curl http://localhost:8000/tools/list | jq .

# 按类别
curl "http://localhost:8000/tools/list?category=data" | jq .

# 排除危险工具
curl "http://localhost:8000/tools/list?exclude_dangerous=true" | jq .

# 列出类别
curl http://localhost:8000/tools/categories | jq .
```

### 获取工具模式

```bash
# 单个工具模式
curl http://localhost:8000/tools/my_tool/schema | jq .

# 所有模式
curl http://localhost:8000/tools/schemas | jq .

# 工具元数据
curl http://localhost:8000/tools/my_tool/metadata | jq .
```

### 执行工具

**直接执行：**
```bash
curl -X POST http://localhost:8000/tools/execute \
  -H "Content-Type: application/json" \
  -d '{
    "tool_name": "calculator",
    "parameters": {"expression": "sqrt(144) + 2^3"}
  }' | jq .
```

**批量执行：**
```bash
curl -X POST http://localhost:8000/tools/batch-execute \
  -H "Content-Type: application/json" \
  -d '[
    {"tool_name": "calculator", "parameters": {"expression": "2+2"}},
    {"tool_name": "calculator", "parameters": {"expression": "10*5"}}
  ]' | jq .
```

**通过工作流：**
```bash
SESSION_ID="test-$(date +%s)" ./scripts/submit_task.sh "计算 2+2 然后乘以 5"
```

### 监控日志

```bash
# 注册日志
docker compose logs llm-service | grep -i "registered tool"
docker compose logs llm-service | grep -i "loaded.*tools"

# 执行日志
docker compose logs -f llm-service orchestrator agent-core

# 工具特定日志
docker compose logs llm-service | grep "my_tool"
```

### 端到端测试

```bash
# 运行所有测试
make smoke

# 运行工具特定测试
./tests/e2e/01_basic_calculator_test.sh
./tests/e2e/06_openapi_petstore_test.sh

# 使用 MCP 工具运行
./tests/e2e/run.sh
```

---

## 故障排除

### 工具未注册

**症状：** 工具未出现在 `/tools/list`

**调试步骤：**
```bash
# 1. 检查 YAML 语法
yamllint config/shannon.yaml

# 2. 检查日志中的错误
docker compose logs llm-service | grep -i error

# 3. 验证启用标志
grep -A 10 "my_tool" config/shannon.yaml | grep enabled

# 4. 强制重新创建服务
docker compose -f deploy/compose/docker-compose.yml up -d --force-recreate llm-service

# 5. 等待健康检查
sleep 10
docker inspect shannon-llm-service-1 --format='{{.State.Health.Status}}'
```

### 域名验证错误

**症状：** `URL host 'example.com' not in allowed domains`

**解决方案：**

1. **开发环境：** 使用通配符
   ```bash
   # .env
   MCP_ALLOWED_DOMAINS=*
   OPENAPI_ALLOWED_DOMAINS=*
   ```

2. **生产环境：** 添加特定域名
   ```bash
   # .env
   MCP_ALLOWED_DOMAINS=localhost,127.0.0.1,api.example.com
   OPENAPI_ALLOWED_DOMAINS=api.example.com,api.github.com
   ```

3. **Docker Compose：** 在环境中设置
   ```yaml
   services:
     llm-service:
       environment:
         - MCP_ALLOWED_DOMAINS=api.example.com
   ```

### 工具执行失败

**症状：** `ToolResult { success: false, error: "..." }`

**调试：**
```bash
# 1. 直接测试工具
curl -X POST http://localhost:8000/tools/execute \
  -H "Content-Type: application/json" \
  -d '{"tool_name":"my_tool","parameters":{...}}' | jq .

# 2. 检查参数类型
curl http://localhost:8000/tools/my_tool/schema | jq '.parameters'

# 3. 验证参数匹配模式
# 必须提供必填参数
# 类型必须匹配（string vs integer）
# 枚举值必须在允许列表中

# 4. 检查 agent core 日志
docker logs shannon-agent-core-1 | grep "Tool execution error"

# 5. 检查 LLM 服务日志
docker logs shannon-llm-service-1 | grep my_tool
```

### LLM 未选择工具

**症状：** LLM 不使用你的工具处理相关查询

**解决方案：**

1. **改进描述：** 使其具体并使用 LLM 友好的关键词
   ```yaml
   # 不好
   description: "天气工具"

   # 好
   description: "获取任何城市的实时天气预报数据，包括温度、湿度和状况。用于有关当前或未来天气的查询。"
   ```

2. **添加到分解上下文：**

   当前限制：编排器向分解传递空工具列表。默认情况下工具不会出现在系统提示中。

   **快速修复：** Agent 服务有自动加载回退（`agent.py` 第 598-609 行）

   **正确修复：** 更新编排器工作流以调用 `fetchAvailableTools()` 并在 `AvailableTools` 字段中传递：
   - `go/orchestrator/internal/workflows/orchestrator_router.go:80`
   - `go/orchestrator/internal/workflows/supervisor_workflow.go:273`

3. **测试工具选择：**
   ```bash
   curl -X POST http://localhost:8000/tools/select \
     -H "Content-Type: application/json" \
     -d '{
       "task": "获取东京的天气预报",
       "max_tools": 3
     }' | jq .
   ```

4. **使用明确提及：**
   ```bash
   ./scripts/submit_task.sh "使用 weather_forecast 工具获取东京的天气"
   ```

### 熔断器触发

**症状：** `Circuit breaker open for <url> (too many failures)`

**调试：**
```bash
# 检查最近错误
docker logs shannon-llm-service-1 --tail 100 | grep -i "circuit\|failure"

# 等待恢复（默认 60 秒）
sleep 60

# 或重启以重置
docker compose restart llm-service
```

**预防：**
- 增加失败阈值：`MCP_CB_FAILURES=10`
- 增加恢复时间：`MCP_CB_RECOVERY_SECONDS=120`
- 修复底层 API 问题

### 速率限制超出

**症状：** `Rate limit exceeded for tool <name>`

**解决方案：**
```bash
# 在配置中增加速率限制
# config/shannon.yaml
rate_limit: 120  # 从默认 60 增加

# 或在工具元数据中（内置工具）
ToolMetadata(
    rate_limit=120,  # 每分钟请求数
    ...
)
```

---

## 安全最佳实践

### 域名白名单

**开发环境：**
```bash
# 宽松的测试环境
MCP_ALLOWED_DOMAINS=*
OPENAPI_ALLOWED_DOMAINS=*
```

**预发布环境：**
```bash
# 特定域名 + localhost
MCP_ALLOWED_DOMAINS=localhost,127.0.0.1,staging-api.example.com
```

**生产环境：**
```bash
# 仅显式白名单
MCP_ALLOWED_DOMAINS=api.example.com,api.partner.com
OPENAPI_ALLOWED_DOMAINS=api.github.com,api.openweathermap.org
```

**子域名匹配：**
- `api.example.com` 允许 `api.example.com` 和 `v1.api.example.com`
- 通配符 `*` 绕过所有验证（谨慎使用！）

### API 密钥管理

**❌ 永远不要硬编码：**
```yaml
# 不好 - 不要这样做！
headers:
  X-API-Key: "sk-1234567890abcdef"
```

**✅ 使用环境变量：**
```yaml
# 好 - 引用环境变量
headers:
  X-API-Key: "${WEATHER_API_KEY}"
```

**存储在 `.env`（不被 git 跟踪）：**
```bash
# .env
WEATHER_API_KEY=sk-real-key-here
STOCK_API_KEY=your-stock-key
```

**生产环境：** 使用密钥管理
- Docker secrets
- Kubernetes secrets
- HashiCorp Vault
- AWS Secrets Manager

### 速率限制

**每个工具限制：**
```yaml
# MCP 工具
mcp_tools:
  expensive_api:
    rate_limit: 10  # 昂贵调用的低限制

# OpenAPI 工具
openapi_tools:
  github:
    rate_limit: 60  # GitHub 的实际限制
```

**全局限制：**
```bash
# .env
MCP_RATE_LIMIT_DEFAULT=60    # 所有 MCP 工具的默认值
```

### 熔断器

**配置：**
```bash
# MCP 熔断器
MCP_CB_FAILURES=5                 # 5 次失败后开启
MCP_CB_RECOVERY_SECONDS=60        # 保持开启 60 秒

# 内置的每个 base_url 熔断器
# - 防止级联故障
# - 隔离行为不当的服务
# - 超时后自动恢复
```

### 认证

**MCP 注册 API：**
```bash
# 动态注册需要令牌
MCP_REGISTER_TOKEN=your-secure-random-token

# 在请求中使用
curl -H "Authorization: Bearer your-secure-random-token" ...
# 或
curl -H "X-Admin-Token: your-secure-random-token" ...
```

**生成安全令牌：**
```bash
openssl rand -hex 32
```

### 危险工具

标记修改状态或访问敏感资源的工具：

```python
ToolMetadata(
    name="file_write",
    dangerous=True,        # 触发 OPA 策略检查
    requires_auth=True,    # 需要用户身份验证
    ...
)
```

**OPA 策略可以进行访问控制：**
```rego
# config/opa/policies/tools.rego
package tools

deny[msg] {
    input.tool == "file_write"
    not is_admin(input.user)
    msg := "file_write 需要管理员角色"
}
```

### 响应大小限制

**防止大响应 DoS：**
```yaml
# OpenAPI 工具
max_response_bytes: 10485760  # 默认 10MB

# MCP 工具（环境变量）
MCP_MAX_RESPONSE_BYTES=10485760
```

### 超时配置

**防止挂起请求：**
```yaml
# OpenAPI 工具
timeout_seconds: 30  # 每个请求超时

# MCP 工具（环境变量）
MCP_TIMEOUT_SECONDS=10
```

### HTTPS 强制

**对于非 localhost URL，Shannon 强制 HTTPS：**
- ✅ `https://api.example.com` - 允许
- ✅ `http://localhost:8080` - 允许
- ❌ `http://api.example.com` - 生产环境拒绝

---

## 下一步

**探索高级主题：**
- [工具实现指南](tools-implementation-guide.md) - 架构深入 (英文)
- [MCP 集成](mcp-integration.md) - 完整 MCP 规范 (英文)
- [Python WASI 执行](python-code-execution.md) - 沙箱代码执行 (英文)

**示例工具：**
- 内置工具：`python/llm-service/llm_service/tools/builtin/`
- MCP 示例：`config/shannon.yaml`（注释示例）
- OpenAPI 示例：`tests/e2e/06_openapi_petstore_test.sh`

**社区：**
- 报告问题：https://github.com/Kocoro-lab/Shannon/issues
- 贡献工具：https://github.com/Kocoro-lab/Shannon/pulls

---

## 总结

**添加工具的三种方式：**

| 方法 | 命令 | 配置文件 | 代码修改 |
|------|------|---------|---------|
| **MCP** | `docker compose up -d --force-recreate llm-service` | `config/shannon.yaml` | 无 |
| **OpenAPI** | `docker compose up -d --force-recreate llm-service` | `config/shannon.yaml` | 无 |
| **内置** | `docker compose up -d --force-recreate llm-service` | `api/tools.py` + 新文件 | 仅 Python |

**关键要点：**
- ✅ 零 proto/Rust/Go 修改（通用 `google.protobuf.Struct` 容器）
- ✅ 内置安全（域名白名单、速率限制、熔断器）
- ✅ 自动成本跟踪（在元数据中设置 `cost_per_use`）
- ✅ 模式驱动（OpenAI 兼容的 JSON 模式）

**快速参考：**
```bash
# 列出工具
curl http://localhost:8000/tools/list

# 获取模式
curl http://localhost:8000/tools/{name}/schema

# 执行
curl -X POST http://localhost:8000/tools/execute \
  -d '{"tool_name":"my_tool","parameters":{...}}'

# 通过工作流
./scripts/submit_task.sh "你的查询在这里"
```

祝工具构建愉快！🛠️

---

*最后更新：2025 年 1 月*

