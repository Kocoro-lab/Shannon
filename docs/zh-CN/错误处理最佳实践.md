# Shannon 错误处理改进提案（RFC）

> **文档类型**: RFC（Request for Comments）  
> **状态**: 📋 征求反馈阶段  
> **创建日期**: 2025年1月15日  
> **反馈截止日期**: 2025年10月25日  
> **预期决策日期**: 2025年10月30日

## RFC元信息

- **提案编号**: RFC-001
- **提案标题**: Shannon错误处理和日志记录系统化改进
- **提案作者**: Engineering Team
- **目标读者**: 后端团队、SRE团队、技术负责人

## 如何提供反馈

1. 在相关PR中评论
2. 参加评审会议（待定）
3. 直接联系提案作者
4. 创建Issue讨论具体改进点

## 概述

本RFC提案概述Shannon在不同层次的现有错误处理机制，分析其优势和不足，并提出系统化的改进方案和实施计划。

**注意**: 本文档中的代码示例和改进建议是**提案内容**，并非已实施的功能。

## 错误处理层次

### 1. Rust Agent Core 层

```rust
// rust/agent-core/src/error.rs
#[derive(Error, Debug)]
pub enum AgentError {
    #[error("Tool '{name}' execution failed: {reason}")]
    ToolExecutionFailed { name: String, reason: String },
    
    #[error("Failed to parse LLM response: {0}")]
    LlmResponseParseError(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    
    #[error("Network request failed: {0}")]
    NetworkError(String),
    
    #[error("Task timeout after {seconds} seconds")]
    TaskTimeout { seconds: u64 },
}
```

**特点：**
- ✅ 使用 `thiserror` 提供结构化错误
- ✅ 明确的错误类型区分
- ✅ 上下文信息丰富

### 2. Go Orchestrator 层

```go
// 工作流错误处理示例
if execErr != nil {
    taskRetries[st.ID]++
    logger.Error("Child SimpleTaskWorkflow failed", 
        "subtask_id", st.ID, 
        "error", execErr, 
        "retry_count", taskRetries[st.ID])
    
    if taskRetries[st.ID] >= maxRetriesPerTask {
        logger.Error("Task exceeded retry limit", 
            "subtask_id", st.ID, 
            "retries", taskRetries[st.ID])
        failedTasks++
        
        if failedTasks >= maxFailures {
            return TaskResult{
                Success: false, 
                ErrorMessage: fmt.Sprintf("Too many failures (%d/%d)", 
                    failedTasks, len(decomp.Subtasks))
            }, fmt.Errorf("workflow aborted due to excessive failures")
        }
    }
}
```

**特点：**
- ✅ 自动重试机制
- ✅ 失败阈值保护
- ✅ 详细的日志记录
- ✅ 优雅降级

### 3. gRPC 服务层

```go
// go/orchestrator/internal/server/service.go
if err != nil {
    s.logger.Error("Failed to start workflow", zap.Error(err))
    return nil, status.Error(codes.Internal, "failed to start workflow")
}
```

**特点：**
- ✅ gRPC 标准错误码
- ✅ 日志记录
- ⚠️ 可以改进：添加更多上下文

## 当前实现的优势

### 1. 分层错误处理

```
客户端请求
    ↓
gRPC 层错误 (codes.*)
    ↓
工作流层错误 (TaskResult.ErrorMessage)
    ↓
活动层错误 (Activity errors)
    ↓
工具层错误 (AgentError)
```

### 2. 自动重试机制

```go
// 工作流级别重试
maxRetriesPerTask := 3
maxFailures := len(decomp.Subtasks) / 2

// 活动级别重试 (Temporal)
activityOptions := workflow.ActivityOptions{
    StartToCloseTimeout: 2 * time.Minute,
    RetryPolicy: &temporal.RetryPolicy{
        InitialInterval:    time.Second,
        BackoffCoefficient: 2.0,
        MaximumInterval:    100 * time.Second,
        MaximumAttempts:    5,
    },
}
```

### 3. 熔断器保护

```go
// Circuit breaker for LLM calls
maxConsecutiveFailures := 5
halfOpenRequests := 2
circuitTimeout := 30 * time.Second
```

### 4. 错误聚合和报告

```go
// 提取工具错误
type ToolError struct {
    AgentID string `json:"agent_id,omitempty"`
    Tool    string `json:"tool,omitempty"`
    Message string `json:"error,omitempty"`
}

func extractToolErrors(result workflows.TaskResult) []ToolError {
    // 从 metadata 提取并格式化错误
    // 截断过长的错误消息 (max 500 chars)
}
```

## 改进建议

### 1. 标准化错误代码

创建统一的错误代码系统：

```go
// go/orchestrator/pkg/errors/codes.go
package errors

type ErrorCode string

const (
    // 客户端错误 (4xx)
    ErrInvalidInput      ErrorCode = "INVALID_INPUT"
    ErrUnauthorized      ErrorCode = "UNAUTHORIZED"
    ErrNotFound          ErrorCode = "NOT_FOUND"
    ErrRateLimitExceeded ErrorCode = "RATE_LIMIT_EXCEEDED"
    
    // 服务端错误 (5xx)
    ErrInternalError     ErrorCode = "INTERNAL_ERROR"
    ErrServiceUnavailable ErrorCode = "SERVICE_UNAVAILABLE"
    ErrTimeout           ErrorCode = "TIMEOUT"
    
    // 工作流错误
    ErrWorkflowFailed    ErrorCode = "WORKFLOW_FAILED"
    ErrToolExecutionFailed ErrorCode = "TOOL_EXECUTION_FAILED"
    ErrLLMError          ErrorCode = "LLM_ERROR"
    ErrPolicyViolation   ErrorCode = "POLICY_VIOLATION"
)

type ShannonError struct {
    Code      ErrorCode              `json:"code"`
    Message   string                 `json:"message"`
    Details   map[string]interface{} `json:"details,omitempty"`
    Retryable bool                   `json:"retryable"`
    Timestamp time.Time              `json:"timestamp"`
}

func (e *ShannonError) Error() string {
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func NewError(code ErrorCode, message string, retryable bool) *ShannonError {
    return &ShannonError{
        Code:      code,
        Message:   message,
        Retryable: retryable,
        Timestamp: time.Now(),
        Details:   make(map[string]interface{}),
    }
}
```

### 2. 增强错误上下文

```go
// 添加请求追踪
type ErrorContext struct {
    RequestID   string
    WorkflowID  string
    SessionID   string
    UserID      string
    TenantID    string
    Operation   string
    Timestamp   time.Time
    StackTrace  string // 仅在开发环境
}

func (e *ShannonError) WithContext(ctx ErrorContext) *ShannonError {
    e.Details["request_id"] = ctx.RequestID
    e.Details["workflow_id"] = ctx.WorkflowID
    // ... 更多上下文
    return e
}
```

### 3. 结构化日志记录

```go
// 使用 zap 的结构化日志
logger.Error("Workflow execution failed",
    zap.String("workflow_id", workflowID),
    zap.String("error_code", string(err.Code)),
    zap.String("session_id", sessionID),
    zap.String("tenant_id", tenantID),
    zap.Bool("retryable", err.Retryable),
    zap.Duration("duration", duration),
    zap.Any("error_details", err.Details),
)
```

### 4. 错误指标和监控

```go
// 添加 Prometheus 指标
var (
    errorCounter = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "shannon_errors_total",
            Help: "Total number of errors by type",
        },
        []string{"code", "component", "retryable"},
    )
    
    errorDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "shannon_error_recovery_duration_seconds",
            Help: "Time to recover from errors",
        },
        []string{"code", "recovery_type"},
    )
)

func RecordError(err *ShannonError, component string) {
    errorCounter.WithLabelValues(
        string(err.Code),
        component,
        fmt.Sprintf("%t", err.Retryable),
    ).Inc()
}
```

### 5. 客户端友好的错误响应

```go
// gRPC 错误映射
func toGRPCError(err *ShannonError) error {
    var code codes.Code
    
    switch err.Code {
    case ErrInvalidInput:
        code = codes.InvalidArgument
    case ErrUnauthorized:
        code = codes.Unauthenticated
    case ErrNotFound:
        code = codes.NotFound
    case ErrRateLimitExceeded:
        code = codes.ResourceExhausted
    case ErrTimeout:
        code = codes.DeadlineExceeded
    case ErrServiceUnavailable:
        code = codes.Unavailable
    default:
        code = codes.Internal
    }
    
    // 添加详细信息到 metadata
    st := status.New(code, err.Message)
    details := &errdetails.ErrorInfo{
        Reason:   string(err.Code),
        Domain:   "shannon.ai",
        Metadata: convertDetailsToStringMap(err.Details),
    }
    st, _ = st.WithDetails(details)
    
    if err.Retryable {
        retryInfo := &errdetails.RetryInfo{
            RetryDelay: durationpb.New(calculateBackoff(err)),
        }
        st, _ = st.WithDetails(retryInfo)
    }
    
    return st.Err()
}
```

### 6. 错误恢复策略

```go
// 智能重试策略
type RetryStrategy struct {
    MaxAttempts     int
    InitialDelay    time.Duration
    MaxDelay        time.Duration
    Multiplier      float64
    Jitter          bool
    RetryableErrors []ErrorCode
}

func (s *RetryStrategy) ShouldRetry(err *ShannonError, attempt int) bool {
    if attempt >= s.MaxAttempts {
        return false
    }
    
    for _, code := range s.RetryableErrors {
        if err.Code == code {
            return true
        }
    }
    
    return err.Retryable
}

func (s *RetryStrategy) NextDelay(attempt int) time.Duration {
    delay := float64(s.InitialDelay) * math.Pow(s.Multiplier, float64(attempt))
    
    if delay > float64(s.MaxDelay) {
        delay = float64(s.MaxDelay)
    }
    
    if s.Jitter {
        jitter := rand.Float64() * delay * 0.1  // ±10% jitter
        delay += jitter - (delay * 0.05)
    }
    
    return time.Duration(delay)
}
```

## 日志记录最佳实践

### 1. 日志级别使用

```go
// TRACE: 非常详细的调试信息
logger.Debug("Entering function", 
    zap.String("function", "ProcessTask"),
    zap.Any("args", args))

// DEBUG: 调试信息
logger.Debug("Processing subtask", 
    zap.String("subtask_id", id))

// INFO: 常规信息
logger.Info("Workflow started", 
    zap.String("workflow_id", wfID))

// WARN: 警告（可恢复的错误）
logger.Warn("Retry attempt", 
    zap.Int("attempt", 2))

// ERROR: 错误（需要关注）
logger.Error("Operation failed", 
    zap.Error(err))

// FATAL: 致命错误（程序将退出）
logger.Fatal("Critical service failure", 
    zap.Error(err))
```

### 2. 日志上下文传递

```go
// 为每个请求创建带上下文的 logger
func WithRequestContext(ctx context.Context, logger *zap.Logger) *zap.Logger {
    requestID := GetRequestID(ctx)
    workflowID := GetWorkflowID(ctx)
    tenantID := GetTenantID(ctx)
    
    return logger.With(
        zap.String("request_id", requestID),
        zap.String("workflow_id", workflowID),
        zap.String("tenant_id", tenantID),
    )
}

// 使用
ctxLogger := WithRequestContext(ctx, logger)
ctxLogger.Info("Processing request")  // 自动包含上下文
```

### 3. 性能日志

```go
// 记录关键操作的性能
func LogPerformance(logger *zap.Logger, operation string, 
                    duration time.Duration, metadata map[string]interface{}) {
    logger.Info("Performance metric",
        zap.String("operation", operation),
        zap.Duration("duration", duration),
        zap.Any("metadata", metadata),
    )
    
    // 同时记录到指标系统
    RecordOperationDuration(operation, duration)
}
```

### 4. 敏感信息过滤

```go
// 过滤敏感字段
type SafeLogger struct {
    logger        *zap.Logger
    sensitiveKeys []string
}

func (l *SafeLogger) sanitize(data map[string]interface{}) map[string]interface{} {
    result := make(map[string]interface{})
    for k, v := range data {
        if contains(l.sensitiveKeys, k) {
            result[k] = "[REDACTED]"
        } else {
            result[k] = v
        }
    }
    return result
}

// 使用
safeLogger := &SafeLogger{
    logger:        zap.L(),
    sensitiveKeys: []string{"password", "api_key", "token", "secret"},
}
```

## 错误处理工具

### 1. 错误分析脚本

```bash
#!/bin/bash
# scripts/analyze_errors.sh

# 分析最近 1 小时的错误日志
docker logs shannon-orchestrator-1 \
  --since 1h \
  --timestamps \
  | grep -E 'ERROR|FATAL' \
  | jq -r 'select(.level=="error") | 
    "\(.ts) [\(.code // "UNKNOWN")] \(.msg) (workflow:\(.workflow_id // "N/A"))"' \
  | sort | uniq -c | sort -rn
```

### 2. 错误追踪仪表板

```python
# scripts/error_dashboard.py
import json
from collections import Counter, defaultdict
from datetime import datetime, timedelta

def analyze_errors(log_file, hours=24):
    """分析错误日志生成报告"""
    errors = defaultdict(list)
    error_counts = Counter()
    
    cutoff = datetime.now() - timedelta(hours=hours)
    
    with open(log_file) as f:
        for line in f:
            try:
                log = json.loads(line)
                if log.get('level') == 'error':
                    timestamp = datetime.fromisoformat(log['ts'])
                    if timestamp > cutoff:
                        code = log.get('code', 'UNKNOWN')
                        error_counts[code] += 1
                        errors[code].append({
                            'timestamp': log['ts'],
                            'message': log['msg'],
                            'workflow_id': log.get('workflow_id'),
                        })
            except:
                continue
    
    # 生成报告
    print(f"错误分析报告 (最近 {hours} 小时)")
    print("=" * 60)
    print(f"\n总错误数: {sum(error_counts.values())}")
    print(f"\n按类型分布:")
    for code, count in error_counts.most_common():
        print(f"  {code}: {count}")
    
    print(f"\n详细信息:")
    for code, items in errors.items():
        print(f"\n{code} ({len(items)} 次):")
        for item in items[-3:]:  # 最近 3 次
            print(f"  - {item['timestamp']}: {item['message']}")
```

### 3. 告警规则

```yaml
# config/alerts/errors.yaml
groups:
  - name: error_rates
    interval: 1m
    rules:
      # 高错误率
      - alert: HighErrorRate
        expr: rate(shannon_errors_total[5m]) > 10
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors/sec"
      
      # 特定错误激增
      - alert: CriticalErrorSpike
        expr: increase(shannon_errors_total{code="WORKFLOW_FAILED"}[5m]) > 5
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "Critical workflow failures"
          description: "{{ $value }} workflow failures in 5 minutes"
      
      # 服务不可用
      - alert: ServiceUnavailable
        expr: shannon_errors_total{code="SERVICE_UNAVAILABLE"} > 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service unavailable errors detected"
```

## 提案实施计划

**注意**: 以下实施计划将在本RFC获得批准后执行。

### 阶段 1：基础设施（1-2 周）
- [ ] 实现 `ShannonError` 类型
- [ ] 添加错误代码常量
- [ ] 创建错误工厂函数
- [ ] 更新 gRPC 错误映射

### 阶段 2：日志增强（1 周）
- [ ] 实现上下文日志记录
- [ ] 添加性能日志
- [ ] 实现敏感信息过滤
- [ ] 创建日志分析工具

### 阶段 3：监控集成（1 周）
- [ ] 添加错误指标
- [ ] 配置告警规则
- [ ] 创建错误仪表板
- [ ] 集成到 CI/CD

### 阶段 4：文档和培训（1 周）
- [ ] 更新错误处理文档
- [ ] 创建故障排除指南
- [ ] 团队培训和最佳实践分享

---

## RFC决策流程

### 下一步行动

1. **反馈收集期** (2025-10-17 至 2025-10-25)
   - 团队成员在PR中提供反馈
   - 收集改进建议和顾虑

2. **提案修订** (2025-10-26 至 2025-10-29)
   - 根据反馈更新提案
   - 解决关键问题

3. **团队决策** (2025-10-30)
   - 召开决策会议
   - 投票决定是否采纳

4. **实施启动** (2025-11-01)
   - 如果批准，创建实施Issue
   - 分配责任人
   - 开始阶段1开发

### 批准标准

- ✅ 至少2名后端工程师Review并批准
- ✅ 技术负责人批准
- ✅ 无重大未解决的技术顾虑
- ✅ 实施计划可行且资源已确认

### 拒绝处理

如果提案被拒绝：
- 记录拒绝原因
- 保留文档供未来参考
- 考虑替代方案

## 参考资料

- [Go 错误处理最佳实践](https://go.dev/blog/error-handling-and-go)
- [gRPC 错误处理](https://grpc.io/docs/guides/error/)
- [Temporal 错误处理](https://docs.temporal.io/dev-guide/go/error-handling)
- [Rust 错误处理](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

---

*文档更新：2025 年 1 月*

