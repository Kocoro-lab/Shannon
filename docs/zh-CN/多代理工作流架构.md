# 多代理工作流架构

## 概述

Shannon 实现了一个现代的、基于模式的多代理工作流系统，通过可组合的模式实现复杂的 AI 推理。该架构遵循清晰的三层设计，消除代码重复，同时为复杂的代理编排提供灵活性。

## 架构层次

```
┌─────────────────────────────────────────────────────────┐
│                   编排器路由                             │
│  （查询分解、复杂度分析、路由）                            │
└─────────────────┬───────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────────┐
│                  策略工作流                              │
│  （DAG、React、Research、Exploratory、Scientific）        │
└─────────────────┬───────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────────┐
│                   模式库                                 │
│  （执行：并行/顺序/混合）                                 │
│  （推理：React/反思/CoT/辩论/ToT）                        │
└─────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. 编排器路由 (`orchestrator_router.go`)
所有查询的入口点，负责：
- **查询分解**：分析查询复杂度并分解为子任务
- **复杂度评分**：确定查询是简单（< 0.3）还是复杂
- **策略选择**：根据认知策略路由到适当的工作流
- **预算管理**：通过中间件强制执行 token 限制

### 2. 策略工作流 (`strategies/`)
为特定方法组合模式的高级工作流：

#### DAG 工作流 (`dag.go`)
- 处理一般任务分解和多代理协调
- 支持并行、顺序和混合（基于依赖）执行
- 应用反思模式进行质量改进

#### React 工作流 (`react.go`)
- 实现推理-行动-观察循环以进行迭代问题解决
- 最适合需要工具使用和环境反馈的任务
- 维护上下文的观察窗口

#### 研究工作流 (`research.go`)
- 优化用于信息收集和综合
- 使用 React 模式进行简单研究，并行代理处理复杂研究
- 应用反思以获得全面结果

#### 探索工作流 (`exploratory.go`)
- 使用思维树模式进行系统化探索
- 置信度低时回退到辩论模式
- 应用反思进行最终质量检查

#### 科学工作流 (`scientific.go`)
- 使用思维链生成假设
- 通过多代理辩论测试假设
- 使用思维树探索影响
- 使用反思进行最终综合

### 3. 模式库 (`patterns/`)
可重用、可组合的代理行为模式：

#### 执行模式 (`execution/`)
- **并行**：使用信号量控制的并发代理执行
- **顺序**：逐步执行并传递结果
- **混合**：使用拓扑排序的依赖图执行

#### 推理模式
- **React** (`react.go`)：具有工具集成的推理-行动-观察循环
- **反思** (`reflection.go`)：通过自我评估进行迭代质量改进
- **思维链** (`chain_of_thought.go`)：具有置信度跟踪的逐步推理
- **辩论** (`debate.go`)：用于探索观点的多代理辩论
- **思维树** (`tree_of_thoughts.go`)：具有分支和剪枝的系统化探索

## 模式组合

工作流组合多个模式以实现复杂推理：

```go
// 示例：科学工作流组合
1. 思维链 → 生成假设
2. 辩论 → 测试竞争假设
3. 思维树 → 探索影响
4. 反思 → 最终质量综合
```

## 工作流选择逻辑

```
查询输入 → 分解和分析
         ↓
    复杂度评分
    ├─ < 0.3 → 简单任务 → 执行简单任务
    └─ ≥ 0.3 → 认知策略
               ├─ exploratory → 探索工作流 → ToT + 辩论 + 反思
               ├─ scientific → 科学工作流 → CoT + 辩论 + ToT + 反思
               ├─ react → React 工作流 → 推理-行动-观察循环
               ├─ research → 研究工作流 → React 或并行 + 反思
               └─ default → DAG 工作流 → 并行/顺序/混合 + 反思
```

## 配置

### 模式配置选项

每个模式通过专用配置结构支持配置：

```go
// 示例：TreeOfThoughtsConfig
type TreeOfThoughtsConfig struct {
    MaxDepth          int     // 最大树深度
    BranchingFactor   int     // 每个节点的分支数（2-4）
    EvaluationMethod  string  // "scoring"、"voting"、"llm"
    PruningThreshold  float64 // 继续分支的最小分数
    ExplorationBudget int     // 探索的最大总思路数
    BacktrackEnabled  bool    // 允许回溯到有希望的分支
    ModelTier         string  // 思维生成的模型层级
}
```

### 工作流配置

工作流通过 `activities.WorkflowConfig` 配置：
- `ExploratoryMaxIterations`：最大探索轮次
- `ExploratoryConfidenceThreshold`：置信度目标
- `ScientificMaxHypotheses`：生成的假设数量
- `ScientificMaxIterations`：最大测试轮次

## Token 预算管理

所有工作流通过以下方式遵守 token 预算：
1. **中间件**：`middleware_budget.go` 强制执行限制
2. **模式选项**：模式选项中的 `BudgetAgentMax` 字段
3. **活动预算**：用于受控执行的 `ExecuteAgentWithBudgetActivity`

## 最佳实践

### 何时使用每个工作流

| 工作流 | 最适合 | 示例查询 |
|--------|--------|---------|
| **简单** | 直接问题、单步任务 | "法国的首都是什么？" |
| **DAG** | 具有明确子任务的多步任务 | "构建带身份验证的 REST API" |
| **React** | 使用工具的任务、迭代问题解决 | "调试这段 Python 代码" |
| **研究** | 信息收集、比较 | "比较 React 和 Vue 框架" |
| **探索** | 开放式发现、未知解决方案空间 | "如何优化我们的数据库？" |
| **科学** | 假设测试、系统化分析 | "测试缓存是否提高 50% 性能" |

### 模式选择指南

1. **使用反思**：当质量比速度更重要时
2. **使用思维链**：当问题需要明确的推理步骤时
3. **使用辩论**：当多个视角加强答案时
4. **使用思维树**：当复杂问题有多个解决路径时
5. **使用 React**：当需要环境反馈时

### 组合策略

1. **从简单开始**：先使用单个模式再组合
2. **逐步分层**：根据置信度阈值添加模式
3. **监控 token**：复杂组合可能很昂贵
4. **实证测试**：测量每个模式的质量改进

## 扩展点

### 添加新模式

1. 在 `patterns/` 中创建模式文件
2. 实现具有标准签名的模式函数：
   ```go
   func YourPattern(ctx workflow.Context, query string, context map[string]interface{},
                    sessionID string, history []string, config YourConfig, opts Options) (*YourResult, error)
   ```
3. 在模式注册表中注册（可选）
4. 在现有或新策略工作流中组合

### 添加新策略

1. 在 `strategies/` 中创建策略文件
2. 实现工作流函数：
   ```go
   func YourWorkflow(ctx workflow.Context, input TaskInput) (TaskResult, error)
   ```
3. 根据需要组合模式
4. 在 `orchestrator_router.go` 中添加路由逻辑
5. 在 `cognitive_wrappers.go` 中创建包装器以实现测试兼容性

## 反思门控

### 概述
Shannon 实现智能反思门控，以在控制成本的同时优化质量。反思根据任务复杂度自动触发。

### 配置
- **阈值**：复杂度 > `ComplexityMediumThreshold` 的任务触发反思
- **默认值**：0.5（可在 `config/shannon.yaml` 中配置）
- **实现**：策略辅助函数中的 `shouldReflect()` 函数

### 何时进行反思
- 需要深度推理的复杂查询
- 具有依赖关系的多步任务
- 需求模糊的任务
- 可按工作流策略配置

## 监控和可观测性

### 指标
- 按类型的工作流启动/完成计数器
- 模式使用频率
- 按模式的 token 消耗
- 反思的质量分数
- 推理模式的置信度级别

### 日志记录
- 每层的结构化日志
- 模式选择推理
- 质量改进跟踪
- Token 预算消耗

### Temporal UI
- 工作流可视化
- 活动时间
- 重试跟踪
- 错误调查

## 人工审批流程

### 概述
Shannon 包含人工审批工作流，用于在执行前需要监督的高风险操作。

### 触发条件
- **复杂度阈值**：复杂度分数 ≥ 0.7 的任务（可通过 `APPROVAL_COMPLEXITY_THRESHOLD` 配置）
- **危险工具**：使用敏感工具的任务，如 `file_system` 或 `code_execution`（可通过 `APPROVAL_DANGEROUS_TOOLS` 配置）

### 配置
```bash
# .env 配置
APPROVAL_ENABLED=true                                  # 启用审批工作流
APPROVAL_COMPLEXITY_THRESHOLD=0.7                      # 复杂度阈值（0.0-1.0）
APPROVAL_DANGEROUS_TOOLS=file_system,code_execution   # 逗号分隔的工具列表
APPROVAL_TIMEOUT_SECONDS=3600                         # 超时时间（秒）（默认：1 小时）
```

### 审批流程
1. 触发时，工作流暂停并生成审批 ID
2. 系统通过 HTTP 端点等待人工决策
3. 批准/拒绝可以包括反馈消息
4. 工作流根据决策继续或终止

### API 端点
```bash
# 批准或拒绝待处理任务
curl -X POST "http://localhost:8081/approvals/decision" \
  -H "Content-Type: application/json" \
  -d '{
    "approval_id": "<approval-id>",
    "workflow_id": "<workflow-id>",
    "approved": true,
    "feedback": "批准用于生产部署"
  }'
```

## 性能考虑

### Token 效率
- 简单任务绕过复杂模式
- 反思仅在质量阈值以下触发
- 并行执行最大化吞吐量
- 缓存防止冗余操作

### 可扩展性
- 信号量控制的并行性（最多 5 个并发代理）
- 依赖感知调度
- 失败服务的熔断器
- 负载下的优雅降级

## 迁移指南

### 从遗留工作流迁移
1. 识别遗留工作流中的核心逻辑
2. 映射到适当的模式
3. 创建组合模式的策略工作流
4. 添加测试包装器以实现兼容性
5. 更新路由器以使用新策略
6. 删除遗留实现

### 模式重构
1. 将公共逻辑提取到辅助函数
2. 创建具有配置选项的模式
3. 用模式调用替换内联逻辑
4. 独立测试模式
5. 在工作流中组合

## 未来增强

### 计划的模式
- **自洽性**：具有投票的多个推理路径
- **从简到难**：从简单到复杂的问题分解
- **ReAct++**：具有规划的增强 React
- **宪法 AI**：价值对齐推理

### 计划的功能
- 基于查询分析的动态模式选择
- 模式性能跟踪和自动调优
- 跨模式上下文共享
- 社区贡献的模式市场

## 结论

Shannon 的多代理工作流架构为复杂的 AI 推理提供了灵活、可扩展的基础。通过组合可重用模式，开发者可以创建强大的工作流，无需代码重复，同时保持清晰的关注点分离。

基于模式的方法与 LangGraph、AutoGen 和 CrewAI 等现代框架保持一致，使 Shannon 对开发者来说很熟悉，同时通过其基于 Temporal 的编排和全面的模式库提供独特的功能。

---

*最后更新：2025 年 1 月*

