# 模式使用指南

## 快速开始

本指南提供使用 Shannon 模式库构建复杂多代理工作流的实用示例。

## 模式目录

### 1. 思维链（Chain-of-Thought, CoT）模式

**用途**：通过明确的思维过程进行逐步推理

**适用场景**：
- 需要展示计算过程的数学问题
- 逻辑证明和推导
- 需要透明性的复杂分析
- 教育性说明

**配置示例**：
```go
config := patterns.ChainOfThoughConfig{
    MaxSteps:              5,        // 最大推理步骤
    RequireExplanation:    true,     // 强制逐步解释
    ShowIntermediateSteps: true,     // 在输出中包含步骤
    ModelTier:             "large",  // 使用更强大的模型进行复杂推理
}
```

**输入/输出流程**：
```
输入: "计算 $1000 在 5% 年利率下 3 年的复利"
   ↓
步骤 1: 确定公式：A = P(1 + r)^t
步骤 2: 代入数值：P=1000, r=0.05, t=3
步骤 3: 计算：1000(1.05)^3
步骤 4: 计算：1000 × 1.157625
步骤 5: 结果：$1,157.63
   ↓
输出: 最终金额为 $1,157.63，利息为 $157.63
```

### 2. 辩论（Debate）模式

**用途**：多代理辩论以探索不同观点

**适用场景**：
- 有争议或主观性的话题
- 需要权衡的决策
- 探索利弊
- 建立共识

**配置示例**：
```go
config := patterns.DebateConfig{
    NumDebaters:      3,              // 辩论代理数量
    MaxRounds:        3,              // 辩论轮次
    Perspectives:     []string{       // 指定观点
        "optimistic",
        "pessimistic",
        "pragmatic",
    },
    RequireConsensus: false,          // 不强制达成一致
    ModeratorEnabled: true,           // 使用主持人进行综合
    VotingEnabled:    true,           // 启用立场投票
}
```

**辩论流程**：
```
问题: "我们应该迁移到微服务架构吗？"
   ↓
第 1 轮: 初始立场
- 乐观派: "可扩展性和团队独立性"
- 悲观派: "复杂性和运维开销"
- 务实派: "取决于团队规模和增长计划"
   ↓
第 2 轮: 反驳论点
- 每个代理回应其他观点
   ↓
第 3 轮: 寻找共同点
- 就渐进式迁移方法达成共识
   ↓
输出: 综合建议及置信度分数
```

### 3. 思维树（Tree-of-Thoughts, ToT）模式

**用途**：通过分支系统性地探索解决方案空间

**适用场景**：
- 具有多个解决路径的问题
- 创造性问题解决
- 战略规划
- 可能需要回溯的情况

**配置示例**：
```go
config := patterns.TreeOfThoughtsConfig{
    MaxDepth:          4,             // 树深度限制
    BranchingFactor:   3,             // 每个节点的分支数
    EvaluationMethod:  "scoring",    // 如何评估路径
    PruningThreshold:  0.3,           // 继续的最小分数
    ExplorationBudget: 15,            // 最大探索思路数
    BacktrackEnabled:  true,          // 允许返回到有希望的分支
}
```

**探索树**：
```
问题: "设计一个容错系统"
        ↓
    [根节点: 系统设计]
    /        |         \
[主-主    [主-备     [被动
 架构]      架构]      备份]
   /  \        /  \       /  \
[负载  [热    [主从  [冷   [温
 均衡] 备份]  复制] 备份] 备份]
   ↓      ↓       ↓      ↓      ↓
(评分) (评分)  (评分)  (评分) (评分)
        ↓
最佳路径: 主-备架构 → 主从复制
```

### 4. ReAct 模式

**用途**：推理-行动-观察循环，用于交互式问题解决

**适用场景**：
- 需要使用工具的任务
- 调试和故障排除
- 迭代改进
- 环境交互

**配置示例**：
```go
config := patterns.ReactConfig{
    MaxIterations:     5,             // 最大 React 循环次数
    ObservationWindow: 3,             // 跟踪最近的观察
    MaxObservations:   20,            // 总观察限制
    MaxThoughts:       10,            // 推理步骤限制
    MaxActions:        10,            // 动作执行限制
}
```

**React 循环**：
```
问题: "调试为什么 API 返回 500 错误"
   ↓
思考: 需要检查服务器日志
动作: execute_command("tail -n 50 /var/log/app.log")
观察: "NullPointerException at line 45"
   ↓
思考: 发现空指针异常，需要检查代码
动作: read_file("api/handler.py", line=45)
观察: "user = request.user.profile"
   ↓
思考: 用户可能没有 profile
动作: add_null_check("if hasattr(request.user, 'profile')")
观察: 已修复并部署
   ↓
输出: 解决了由缺少用户 profile 导致的 500 错误
```

### 5. 反思（Reflection）模式

**用途**：通过自我评估进行迭代质量改进

**适用场景**：
- 最终质量优化
- 需要验证的关键输出
- 初始结果低于阈值时
- 持续改进循环

**配置示例**：
```go
config := patterns.ReflectionConfig{
    Enabled:             true,
    MaxRetries:          3,           // 改进迭代次数
    ConfidenceThreshold: 0.85,        // 目标质量分数
    Criteria: []string{               // 评估维度
        "accuracy",
        "completeness",
        "clarity",
    },
    TimeoutMs:           30000,       // 每次反思的超时时间
}
```

**反思过程**：
```
初始结果 → 评估 (分数: 0.6)
   ↓
问题: 缺少具体示例，结论不清晰
   ↓
改进结果 → 评估 (分数: 0.8)
   ↓
问题: 缺少边界情况
   ↓
最终结果 → 评估 (分数: 0.9) ✓
```

## 模式组合示例

### 示例 1: 科学研究

**工作流**: ScientificWorkflow
**组合**: CoT → Debate → ToT → Reflection

```go
// 阶段 1: 使用思维链生成假设
hypotheses := ChainOfThought(
    "为性能问题生成 3 个可测试的假设",
    ChainOfThoughtConfig{MaxSteps: 3, RequireExplanation: true},
)

// 阶段 2: 通过辩论测试假设
testResults := Debate(
    "哪个假设最能解释数据？",
    DebateConfig{NumDebaters: 3, Perspectives: hypotheses},
)

// 阶段 3: 使用思维树探索影响
implications := TreeOfThoughts(
    "获胜假设的影响是什么？",
    TreeOfThoughtsConfig{MaxDepth: 3, BranchingFactor: 2},
)

// 阶段 4: 使用反思优化
finalReport := Reflection(
    combineResults(hypotheses, testResults, implications),
    ReflectionConfig{ConfidenceThreshold: 0.9},
)
```

### 示例 2: 复杂问题解决

**工作流**: ExploratoryWorkflow
**组合**: ToT (主要) → Debate (如果置信度低) → Reflection (最终)

```go
// 使用思维树进行主要探索
exploration := TreeOfThoughts(
    "如何优化数据库性能？",
    TreeOfThoughtsConfig{
        MaxDepth: 4,
        BranchingFactor: 3,
        BacktrackEnabled: true,
    },
)

// 如果置信度 < 阈值，应用辩论
if exploration.Confidence < 0.7 {
    debate := Debate(
        "评估前 3 个优化策略",
        DebateConfig{
            NumDebaters: 3,
            Perspectives: exploration.TopPaths,
        },
    )
    exploration = mergeResults(exploration, debate)
}

// 最终质量检查
final := Reflection(
    exploration,
    ReflectionConfig{MaxRetries: 2},
)
```

### 示例 3: 交互式调试

**工作流**: ReactWorkflow with Reflection
**组合**: React (主循环) → Reflection (结果质量)

```go
// 用于调试的主 React 循环
debugging := React(
    "查找并修复内存泄漏",
    ReactConfig{
        MaxIterations: 10,
        ObservationWindow: 5,
    },
)

// 确保解决方案质量
solution := Reflection(
    debugging.Solution,
    ReflectionConfig{
        Criteria: []string{"correctness", "completeness"},
    },
)
```

## 执行模式

### 并行执行

**适用场景**：任务相互独立
**优点**：最大吞吐量
**限制**：没有共享上下文

```go
// 执行多个独立分析
results := ParallelExecution(
    subtasks: []Task{
        "分析性能指标",
        "审查安全日志",
        "检查错误率",
    },
    config: ParallelConfig{
        MaxConcurrency: 3,
        Timeout: 60000,
    },
)
```

### 顺序执行

**适用场景**：任务相互依赖
**优点**：上下文累积
**限制**：整体速度较慢

```go
// 逐步数据管道
results := SequentialExecution(
    subtasks: []Task{
        "从源提取数据",
        "转换为标准格式",
        "验证数据质量",
        "加载到目标",
    },
    config: SequentialConfig{
        PassContext: true,
    },
)
```

### 混合执行

**适用场景**：任务有依赖关系
**优点**：带约束的最优并行
**限制**：复杂的依赖管理

```go
// 使用依赖图执行
results := HybridExecution(
    tasks: map[string]Task{
        "A": {Query: "任务 A"},
        "B": {Query: "任务 B", Dependencies: []string{"A"}},
        "C": {Query: "任务 C", Dependencies: []string{"A"}},
        "D": {Query: "任务 D", Dependencies: []string{"B", "C"}},
    },
)
// 执行顺序: A → (B || C) → D
```

## 模式选择决策树

```
开始 → 问题是否明确定义？
         ├─ 否 → 使用 ExploratoryWorkflow (ToT + Debate)
         └─ 是 → 是否需要多个视角？
                   ├─ 是 → 是否需要系统化测试？
                   │         ├─ 是 → 使用 ScientificWorkflow (CoT + Debate + ToT)
                   │         └─ 否 → 使用 Debate 模式
                   └─ 否 → 是否需要工具交互？
                           ├─ 是 → 使用 ReactWorkflow
                           └─ 否 → 是否需要复杂推理？
                                   ├─ 是 → 使用 Chain-of-Thought
                                   └─ 否 → 使用简单执行
```

## 性能优化技巧

### Token 优化

1. **从简单模式开始**，再使用复杂组合
2. **使用置信度阈值**跳过不必要的模式
3. **为每个模式配置适当的模型层级**
4. **为 ToT 模式设置探索预算**
5. **根据收敛情况限制辩论轮次**

### 质量与速度权衡

| 优先级 | 模式选择 | 配置 |
|--------|---------|------|
| **速度** | 跳过反思，限制迭代 | `MaxRetries: 1, MaxIterations: 3` |
| **质量** | 添加反思，增加探索 | `ConfidenceThreshold: 0.9, MaxDepth: 5` |
| **平衡** | 基于置信度的条件模式 | `if confidence < 0.7: add_pattern()` |

### 调试模式问题

**模式不收敛**：
- 增加最大迭代/轮次
- 调整置信度阈值
- 检查查询是否格式良好

**Token 使用过多**：
- 减少分支因子 (ToT)
- 限制辩论轮次
- 使用较小的模型层级
- 设置更严格的探索预算

**结果质量差**：
- 添加反思模式
- 提高模型层级
- 添加更多评估标准
- 使用多个模式

## 高级技巧

### 动态模式选择

```go
func SelectPatternDynamically(query string, context map[string]interface{}) Pattern {
    complexity := analyzeComplexity(query)
    uncertainty := measureUncertainty(context)

    if complexity > 0.8 && uncertainty > 0.7 {
        return ComposePatterns(TreeOfThoughts, Debate, Reflection)
    } else if complexity > 0.5 {
        return ComposePatterns(ChainOfThought, Reflection)
    } else {
        return React
    }
}
```

### 模式结果缓存

```go
// 为相似查询缓存模式结果
cacheKey := hash(pattern_type, query, config)
if cached := cache.Get(cacheKey); cached != nil {
    return cached
}
result := pattern.Execute(query, config)
cache.Set(cacheKey, result, ttl=3600)
```

### 跨模式上下文共享

```go
// 跨模式共享见解
sharedContext := map[string]interface{}{
    "previous_patterns": []string{"ChainOfThought"},
    "insights": cotResult.ReasoningSteps,
    "confidence": cotResult.Confidence,
}

// 下一个模式可以利用之前的见解
debateResult := Debate(query, config, sharedContext)
```

## 总结

Shannon 的模式库为复杂的 AI 推理提供了强大的构建块。通过理解每种模式的优势和最佳使用场景，开发者可以为任何问题领域构建有效的工作流。从单一模式开始，衡量其有效性，然后根据需要逐步组合更复杂的工作流。

---

## 相关文档

- [多代理工作流架构](multi-agent-workflow-architecture.md) (英文)
- [扩展 Shannon](extending-shannon.md) (英文)
- [添加自定义工具](adding-custom-tools.md) (英文)
- [快速开始指南](快速开始.md)

---

*最后更新：2025 年 1 月*

